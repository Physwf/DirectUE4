#pragma once

#include "DeferredShadingCommon.dusf"
#include "BSDF.dusf"
#include "FastMath.dusf"
#include "CapsuleLight.dusf"
#include "RectLight.dusf"
//#include "TransmissionCommon.ush"


struct FAreaLight
{
    float       SphereSinAlpha;
    float		SphereSinAlphaSoft;
    float		LineCosSubtended;

	float3		FalloffColor;

    FRectLight	Rect;
	Texture2D	Texture;
	bool		bIsRect;
};

struct FShadowTerms
{
    float SurfaceShadow;
    float TransmissionShadow;
    float TransmissionThickness;
};

float New_a2( float a2, float SinAlpha, float VoH )
{
	return a2 + 0.25 * SinAlpha * (3.0 * sqrtFast(a2) + SinAlpha) / ( VoH + 0.001 );
	//return a2 + 0.25 * SinAlpha * ( saturate(12 * a2 + 0.125) + SinAlpha ) / ( VoH + 0.001 );
	//return a2 + 0.25 * SinAlpha * ( a2 * 2 + 1 + SinAlpha ) / ( VoH + 0.001 );
}

float EnergyNormalization( inout float a2, float VoH, FAreaLight AL )
{
	if( AL.SphereSinAlphaSoft > 0 )
	{
		// Modify Roughness
		a2 = saturate( a2 + Pow2( AL.SphereSinAlphaSoft ) / ( VoH * 3.6 + 0.4 ) );
	}

	float Sphere_a2 = a2;
	float Energy = 1;
	if( AL.SphereSinAlpha > 0 )
	{
		Sphere_a2 = New_a2( a2, AL.SphereSinAlpha, VoH );
		Energy = a2 / Sphere_a2;
	}

	if( AL.LineCosSubtended < 1 )
	{
#if 1
		float LineCosTwoAlpha = AL.LineCosSubtended;
		float LineTanAlpha = sqrt( ( 1.0001 - LineCosTwoAlpha ) / ( 1 + LineCosTwoAlpha ) );
		float Line_a2 = New_a2( Sphere_a2, LineTanAlpha, VoH );
		Energy *= sqrt( Sphere_a2 / Line_a2 );
#else
		float LineCosTwoAlpha = AL.LineCosSubtended;
		float LineSinAlpha = sqrt( 0.5 - 0.5 * LineCosTwoAlpha );
		float Line_a2 = New_a2( Sphere_a2, LineSinAlpha, VoH );
		Energy *= Sphere_a2 / Line_a2;
#endif
	}

	return Energy;
}


float3 SpecularGGX( float Roughness, float3 SpecularColor, BxDFContext Context, float NoL, FAreaLight AL )
{
	float a2 = Pow4( Roughness );
	float Energy = EnergyNormalization( a2, Context.VoH, AL );
	
	// Generalized microfacet specular
	float D = D_GGX( a2, Context.NoH ) * Energy;
	float Vis = Vis_SmithJointApprox( a2, Context.NoV, NoL );
	float3 F = F_Schlick( SpecularColor, Context.VoH );

	return (D * Vis) * F;
}

struct FDirectLighting
{
    float3 Diffuse;
    float3 Specular;
    float3 Transmission;
};

FDirectLighting DefaultLitBxDF( FGBufferData GBuffer, half3 N, half3 V, half3 L, float Falloff, float NoL, FAreaLight AL, FShadowTerms Shadow )
{
    BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AL.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );

    FDirectLighting Lighting;
	Lighting.Diffuse  = AL.FalloffColor * (Falloff * NoL) * Diffuse_Lambert( GBuffer.DiffuseColor );

    if( AL.bIsRect )
		Lighting.Specular = RectGGXApproxLTC( GBuffer.Roughness, GBuffer.SpecularColor, N, V, AL.Rect, AL.Texture );
	else
		Lighting.Specular = AL.FalloffColor * (Falloff * NoL) * SpecularGGX( GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AL );

	Lighting.Transmission = 0;
	return Lighting;
}


FDirectLighting IntegrateBxDF(FGBufferData GBuffer, half3 N, half3 V,  half3 L, float Falloff, float NoL, FAreaLight AL, FShadowTerms Shadow)
{
    switch(GBuffer.ShadingModelID)
    {
        case SHADINGMODELID_DEFAULT_LIT:
            return DefaultLitBxDF(GBuffer,N,V,L,Falloff,NoL,AL,Shadow);
        default:
            return (FDirectLighting)0;
    }
}